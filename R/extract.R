##' Return the number of sequences per entry in a set of zip archives generated by FastQC.
##'
##' To be used after readFastqcZips().
##' @param all.qc return value from readFastqcZips()
##' @return numeric vector
##' @author Timothee Flutre [cre,aut]
extractFastqcNreads <- function(all.qc){
  stopifnot(is.list(all.qc), ! is.null(names(all.qc)))
  sapply(all.qc, function(qc){
    as.numeric(qc[["Basic_Statistics"]]$Value[qc[["Basic_Statistics"]]$Measure
                                              == "Total Sequences"])
  })
}

##' Return the number, or percentage, of sequences per quality score per entry in a set of zip archives generated by FastQC.
##'
##' To be used after readFastqcZips().
##' @param all.qc return value from readFastqcZips()
##' @param perc return percentage of sequences if TRUE, number of sequences otherwise
##' @param nreads return value from nreads.fastqc(), required if perc=TRUE
##' @return numeric matrix with entries in rows and number (percentage) of sequences per quality in columns
##' @author Timothee Flutre [cre,aut]
extractFastqcQuals <- function(all.qc, perc=FALSE, nreads=NULL){
  stopifnot(is.list(all.qc), ! is.null(names(all.qc)),
            ifelse(perc, ! is.null(nreads), TRUE))
  N <- length(all.qc)
  qual <- matrix(NA, nrow=N, ncol=50,
                 dimnames=list(names(all.qc), paste0("Q=", 1:50)))
  for(i in 1:N)
    qual[i, all.qc[[i]][["Per_sequence_quality_scores"]][,"Quality"]] <-
      all.qc[[i]][["Per_sequence_quality_scores"]][,"Count"]
  if(perc)
    for(i in 1:nrow(qual))
      qual[i,] <- (qual[i,] / nreads[i]) * 100
  return(qual)
}

##' Returns the adapter content along the sequences per entry in a set of zip archives generated by FastQC.
##'
##' To be used after readFastqcZips().
##' @param all.qc return value from readFastqcZips()
##' @param adp name of the adapter to plot (default="Illumina Universal Adapter")
##' @return numeric matrix with entries in rows and positions along sequences in columns
##' @author Timothee Flutre [cre,aut], Nicolas Rode [ctb]
extractFastqcAdpContents <- function(all.qc, adp="Illumina Universal Adapter"){
  stopifnot(is.list(all.qc), ! is.null(names(all.qc)))
  N <- length(all.qc)
  L <- NULL
  for(i in 1:N)
    L <- c(L, length(all.qc[[i]]$Adapter_Content[["Position"]]))
  max.idx <- which(L == max(L))[1]
  positions <- all.qc[[max.idx]]$Adapter_Content[["Position"]]
  adp.content <- matrix(NA, nrow=N, ncol=length(positions),
                        dimnames=list(names(all.qc), positions))
  for(i in 1:N){
    stopifnot(adp %in% names(all.qc[[i]]$Adapter_Content))
    dif <- L[max.idx] - L[i]
    if(dif == 0){
      adp.content[i,] <- all.qc[[i]]$Adapter_Content[[adp]]
    } else
      adp.content[i,] <- c(all.qc[[i]]$Adapter_Content[[adp]], rep(0,dif))
  }
  return(adp.content)
}

##' Returns the N counts per entry in a set of zip archives generated by FastQC.
##'
##'
##' To be used after readFastqcZips().
##' @param all.qc return value from readFastqcZips()
##' @return numeric matrix with entries in rows and positions along sequences in columns
##' @author Timothee Flutre [cre,aut]
extractFastqcBaseNs <- function(all.qc){
  stopifnot(is.list(all.qc), ! is.null(names(all.qc)))
  N <- length(all.qc)
  L <- NULL
  for(i in 1:N)
    L <- c(L, length(all.qc[[i]]$Per_base_N_content[,"Base"]))
  max.idx <- which(L == max(L))[1]
  positions <- all.qc[[max.idx]]$Per_base_N_content[,"Base"]
  baseN <- matrix(NA, nrow=N, ncol=length(positions),
                  dimnames=list(names(all.qc), positions))
  for(i in 1:N){
    dif <- L[max.idx] - L[i]
    if(dif == 0){
      baseN[i,] <- all.qc[[i]]$Per_base_N_content[,"N-Count"]
    } else
      baseN[i,] <- c(all.qc[[i]]$Per_base_N_content[,"N-Count"], rep(0,dif))
  }
  return(baseN)
}

##' Returns the sequence length distribution per entry in a set of zip archives generated by FastQC.
##'
##' To be used after readFastqcZips().
##' @param all.qc return value from readFastqcZips()
##' @return numeric matrix with entries in rows and positions along sequences in columns
##' @author Timothee Flutre [cre,aut], Nicolas Rode [ctb]
extractFastqcSeqLengths <- function(all.qc){
  stopifnot(is.list(all.qc), ! is.null(names(all.qc)))
  N <- length(all.qc)
  positions <- lapply(1:N, function(i){
    as.character(all.qc[[i]]$Sequence_Length_Distribution[["Length"]])
  })
  positions <- unique(sort(sapply(
      strsplit(do.call(c, positions), "-"), function(x){
        as.numeric(x[1])
      })))
  seq.lengths <- matrix(0, nrow=N, ncol=length(positions),
                        dimnames=list(names(all.qc), positions))
  for(i in 1:N){
    tmp <- all.qc[[i]]$Sequence_Length_Distribution
    if (length(grep("-",tmp$Length)) != 0)
      tmp$Length <- sapply(strsplit(tmp$Length, "-"), function(x){x[1]})
    seq.lengths[i,as.character(tmp$Length)] <- tmp$Count
  }
  return(seq.lengths)
}
